import { draw_all_people } from "./fhh_display_pedigree.js";


var data = {};

export function set_data (d) {
  data = d;
}

export function build_entire_family_tree() {
  let family_tree = build_family_tree_with_ancestors();


  let tree_is_complete = false;
  let generation = 0;
  while (!tree_is_complete) {
    family_tree[generation] = expand_one_generation_to_include_partners(family_tree[generation]);

    family_tree[generation + 1] = expand_next_generation_to_include_all_children(family_tree[generation + 1], family_tree[generation]);
    if (!family_tree[generation + 1] || family_tree[generation + 1].length == 0) {
      tree_is_complete = true;
    } else {
      generation = generation + 1;
    }
  }
  // The last generation is empty, so lets get rid of it
  family_tree.pop();
  console.log(family_tree);
  return family_tree;
}

export function build_family_tree_with_ancestors() {
  const proband_id = data['proband'];

  let tree = [];
  // First go up the tree from the proband to find all ancestors.
  // Each generation is an array of members ordered as they will be on display

  let list;
  if (data["people"][proband_id]["demographics"]["gender"] == "Male") {
    list = [{"father":proband_id}];
  } else {
    list = [{"mother":proband_id}];
  }

  list.ancestor = true;
  tree.push(list);

  let i = 0;
  while (tree[i] && tree[i].length > 0) {
    const new_list = find_all_parents_of_list(tree[i], i);
    if (new_list && new_list.length > 0) tree.push(new_list);
    i++;
  }
  // We need to get the oldest generation to be the first (ie. [0]) and each generation to go up from there
  tree.reverse();
  return tree;
}

export function find_orphaned_people() {
    let orphaned_list = [];
    const all_people = data["people"];
    for (const person_id in all_people) {
//      console.log (person_id + ":" + all_people[person_id].father + "," + all_people[person_id].mother);
      if (!all_people[person_id].father && !all_people[person_id].mother) orphaned_list.push(person_id);
    }
    return orphaned_list;
}

export function place_orphaned_people() {
  const orphaned_people = find_orphaned_people();

  for (const i in orphaned_people) {
    const children = find_children(orphaned_people[i]);
//    console.log(orphaned_people[i] + ":" + children);


  }
}

export function find_in_tree (person_id, family_tree) {
  console.log("In find_in_tree");

  for (const i in family_tree) {
    const generation = family_tree[i];
    for (const i2 in generation) {
      const couple = generation[i2];
      if (couple.father == person_id || couple.mother == person_id) {
        if (couple.father == person_id) console.log("M(" + couple.father  + " ) at:" + i + "," + i2);
        if (couple.mother == person_id) console.log("F(" + couple.mother  + " ) at:" + i + "," + i2);

      }
    }
  }
}

export function find_couple_in_tree(father_id, mother_id, family_tree) {
  for (const i in family_tree) {
    const generation = family_tree[i];
    for (const i2 in generation) {
      const couple = generation[i2];
      if (couple.father == father_id && couple.mother == mother_id) {
        return couple;
      }
    }
  }
  return null;
}
export function expand_one_generation_to_include_partners(generation) {

  let updated_generation = [];
// Need to do a deep copy of generation
//  for (const i in generation) updated_generation.push(generation[i]);

  for (const i in generation) {

    // Check to see if there are any half-relations, if all_partners == 0 or undefined, then no halfs
    const couple = generation[i];
    let all_partners = find_all_partners(couple.father);
    if (all_partners && all_partners.length == 0) {
      couple.blood = true;
      updated_generation.push(couple);
    } else {
      // First push all the couples with a non-blood mother to the list so the extra female partners will be to the left
      for (const i2 in all_partners) {
        const new_mother = all_partners[i2];
        if (new_mother != couple.mother) {
          let new_couple = {"mother": new_mother, "father":couple.father} ;
          console.log("Here - 1");
          console.log(couple);
          new_couple.children = find_children_from_couple(new_couple);
          if (!couple_already_in_array(updated_generation, new_couple)) updated_generation.push(new_couple);
        }
      }
    }

    // This adds the main couple to to list
    if (couple.mother && couple.father) {
      couple.blood = true;
      // Have to iterate over every element to ensure it is not already there,
      if (!couple_already_in_array(updated_generation, couple) ) updated_generation.push(couple);
    }

    // Check to see if there are any half-relations, if all_partners == 0 or undefined, then no halfs
    all_partners = find_all_partners(couple.mother);
    if (all_partners && all_partners.length == 0) {
      couple.blood = true;
      updated_generation.push(couple);
    } else {
      // Then push all the couples with a non-blood father to the list so the extra male partners will be to the right
      for (const i2 in all_partners) {
        const new_father = all_partners[i2];
        if (new_father != couple.father) {
          let new_couple = {"mother": couple.mother, "father":new_father} ;
          console.log("Here - 2");
          console.log(couple);
          new_couple.children = find_children_from_couple(new_couple);
          if (!couple_already_in_array(updated_generation, new_couple)) updated_generation.push(new_couple);
        }
      }
    }
  }

  return updated_generation;
}

export function maybe_expand_one_generation_to_include_partners(generation) {

  let updated_generation = [];
// Need to do a deep copy of generation
//  for (const i in generation) updated_generation.push(generation[i]);

  for (const i in generation) {
    const couple = generation[i];


    // This adds the main couple to to list
    if (couple.mother && couple.father) {
      couple.blood = true;
      // Have to iterate over every element to ensure it is not already there,
      if (!couple_already_in_array(updated_generation, couple) ) updated_generation.push(couple);
    }

  }
  for (const i in generation) {
    // Check to see if there are any half-relations, if all_partners == 0 or undefined, then no halfs
    const couple = generation[i];
    let all_partners = find_all_partners(couple.father);
    if (all_partners && all_partners.length == 0) {
      couple.blood = true;
      updated_generation.push(couple);
    } else {
      // First push all the couples with a non-blood mother to the list so the extra female partners will be to the left
      for (const i2 in all_partners) {
        const new_mother = all_partners[i2];
        if (new_mother != couple.mother) {
          let new_couple = {"mother": new_mother, "father":couple.father} ;
          console.log("Here - 3");
          new_couple.children = find_children_from_couple(new_couple);
          if (!couple_already_in_array(updated_generation, new_couple)) updated_generation.push(new_couple);
        }
      }
    }
    // Check to see if there are any half-relations, if all_partners == 0 or undefined, then no halfs
    all_partners = find_all_partners(couple.mother);
    if (all_partners && all_partners.length == 0) {
      couple.blood = true;
      updated_generation.push(couple);
    } else {
      // Then push all the couples with a non-blood father to the list so the extra male partners will be to the right
      for (const i2 in all_partners) {
        const new_father = all_partners[i2];
        if (new_father != couple.father) {
          let new_couple = {"mother": couple.mother, "father":new_father} ;
          console.log("Here - 4");
          new_couple.children = find_children_from_couple(new_couple);
          if (!couple_already_in_array(updated_generation, new_couple)) updated_generation.push(new_couple);
        }
      }
    }


  }
  return updated_generation;
}


function couple_already_in_array(array, couple) {
  let already_in_array = false;
  for (const i in array) {
    const test_couple = array[i];
    if (couple.mother == test_couple.mother && couple.father == test_couple.father) {
      already_in_array = true;
    }
  }
  return already_in_array;
}



export function maybe_expand_next_generation_to_include_all_children(next_generation, current_generation) {
  if (!next_generation) next_generation = [];  // When there are no people in a generation, we still needed to expand if there are are children
  next_generation = [];
  let new_generation = next_generation;
  for (const i in current_generation) {
    console.log("Here - 5");
    let children = find_children_from_couple(current_generation[i]);
    if (!children || children.length == 0) {
//      console.log("No children for:" + current_generation[i].father + ":" + current_generation[i].mother);


//      const placeholder_couple = {"father":"placeholder", "mother":"P_"+current_generation[i].father+"-"+current_generation[i].mother};
//      new_generation.push(placeholder_couple);
    }
    for (const i2 in children) {
      const child = children[i2];
      const location_in_generation = find_in_generation(child, next_generation);
      let loc = 0;
      let sibling;

      if (!location_in_generation) {
        // This person is not a direct ancestor (uncle, aunt, etc.) so we need to find the direct ancestor and put them nearby

        const all_siblings = find_any_siblings(child);

        if (all_siblings && all_siblings.length > 0) {
          for (const i in all_siblings) {
            sibling = all_siblings[i];
            if (find_in_generation(sibling, next_generation) > 0) loc = find_in_generation(sibling, next_generation);
          }
        }
        if (determine_sex(sibling) == "Male") loc = loc + 1;  // If sibling is male, than put it after him
        const sex = determine_sex(child);
        if (sex == "Male") {
          const child_as_couple = {"father": child }; // Always work with couples, even when we don't know if they have children
          new_generation.splice(loc, 0, child_as_couple);
        } else {
          const child_as_couple = {"mother": child }; // Always work with couples, even when we don't know if they have children
          new_generation.splice(loc, 0, child_as_couple);
        }
      }
    }
  }
  return new_generation;
}



export function expand_next_generation_to_include_all_children(next_generation, current_generation) {
  let new_generation = [];


  let at_least_one_real_child = false;
  for (const i in current_generation) {
    console.log("Here - 6");
    let children = find_children_from_couple(current_generation[i]);
    if (!children || children.length == 0) {
//      const placeholder_id = Math.floor(new Date().valueOf() * Math.random());
//      const placeholder_couple = {"father":placeholder_id};
//      placeholder_couple.placeholder = true;
//      new_generation.push(placeholder_couple);
//      data["people"][placeholder_id] = {"father":current_generation[i].father, "mother":current_generation[i].mother }
    } else {
      at_least_one_real_child = true;
      for (const i2 in children) {
        const child = children[i2];
        if (determine_sex(child)== "Male") {
          const child_as_couple = {"father": child }; // Always work with couples, even when we don't know if they have children
          new_generation.push(child_as_couple);
          console.log(child_as_couple);
        } else {
          const child_as_couple = {"mother": child }; // Always work with couples, even when we don't know if they have children
          new_generation.push(child_as_couple);
          console.log(child_as_couple);
        }
      }
    }
  }
//  for (const i in next_generation) {
//    new_generation.push(next_generation[i]);
//  }
  //console.log(new_generation);
  if (at_least_one_real_child) return new_generation;
  else return null;
}

export function create_couple_list_from_single_parent_list(single_parent_list){
  for (const i in single_parent_list) {
    const parent_id = single_parent_list[i];
    const partner_list = find_all_partners(parent_id);
    for (const i2 in partner_list) {
      const couple = {"father": parent_id, "mother": partner_list[i2]};
    }
  }

}

function find_in_generation(person_id, generation) {
  for (const i in generation) {
    const couple = generation[i];
    if (couple.mother == person_id || couple.father == person_id) {
      return i;
    }
  }
}

export function find_first_in_generation(person_id, generation) {
  for (const i in generation) {
    const couple = generation[i];
    console.log (i + ":" + generation[i].father + "," + generation[i].mother);
    if (couple.mother == person_id || couple.father == person_id) {
      console.log (i + ":" + generation[i].father +"," + generation[i].mother);
      console.log (i + ":" + couple.loc);
      return Number(i);
    }
  }
}

export function find_last_in_generation(person_id, generation) {
  let last_loc = -1;
  for (const i in generation) {
    const couple = generation[i];
    if (couple.mother == person_id || couple.father == person_id) {
      last_loc = i;
    }
  }
  if (last_loc >= 0) return Number(last_loc);
  else return null;
}

export function set_all_locations(family_tree) {
  console.log("set_all_locations");

  // Start at bottom
  for (let i = family_tree.length-1; i>=0; i--) {
//  for (let i = 0; i< family_tree.length; i++) {
    const generation = family_tree[i];
    // each generation we start on the left again
    let current_loc = 0;
    for (const i2 in generation) {
      const couple = generation[i2];
      current_loc = current_loc + 1;
      couple.loc = current_loc;
      if (couple.children) {
        const first_child = find_first_in_generation(couple.children[0], family_tree[i+1]);
        const first_loc = family_tree[i+1][first_child].loc;
        const last_child = find_last_in_generation(couple.children[couple.children.length-1], family_tree[i+1]);
        const last_loc = family_tree[i+1][last_child].loc;

        console.log(couple.father + "," + couple.mother + ": " + couple.loc + " [" + first_loc + "," + last_loc + "]");
        console.log(first_loc + "," + last_loc);
        if (couple.loc < (first_loc + last_loc) / 2 ) {
          current_loc = Math.floor ((first_loc + last_loc) / 2) ;
        }
      }
//      couple.loc = current_loc;
      couple.gen = Number(i);

    }
  }

//  move_children_under_parents(family_tree);
//  move_people_if_overlap(family_tree);

  // Sometimes couples are put ontop of each other, when this happens, we need to push some out to the right

}

// lets start with the second to last generation to put the children under their parents
function   move_children_under_parents(family_tree) {
  for (let i = 1; i< family_tree.length; i++) {
    const parent_generation = family_tree[i];
    for (const i in parent_generation) {
      let couple = parent_generation[i];
      fix_location_under_parents(couple, family_tree);
    }
  }
}

function   move_people_if_overlap(family_tree) {
  let max = 0;
  for (let i = 1; i< family_tree.length; i++) {
    const generation = family_tree[i];
    for (let i2 = 1; i2 < family_tree.length; i2++) {
      let couple = generation[i2];
      let last_couple = generation[i2-1];
      if (couple && last_couple) {
        console.log("(" + couple.father + "," + couple.mother + ")(" + last_couple.father + "," + last_couple.mother + ":" + couple.loc + "," + last_couple.loc);
        if (couple.loc <= last_couple.loc) {
          console.log("Moving:" + couple.father + "," + couple.mother + " to " + (Number(couple.loc) + 1)  );
          couple.loc = couple.loc + 1;
        }
      }
    }
  }
}

function fix_location_under_parents(couple, family_tree) {
  let dads_parents = find_parent_of_male_in_couple(couple, family_tree);
  let dads_location = 0;
  if (dads_parents) {
    dads_location = dads_parents.loc
  }
  let moms_parents = find_parent_of_female_in_couple(couple, family_tree);
  let moms_location = 0;
  if (moms_parents) {
    moms_location = moms_parents.loc
  }
  let current_loc = couple.loc;
  console.log(couple.father + ":" + couple.mother + ")" + couple.loc + "->" + dads_location + "," + moms_location);
  if (couple.loc < dads_location) couple.loc = dads_location;
  if (couple.loc < moms_location) couple.loc = moms_location;

}

export function maybe_set_all_locations(family_tree) {
  console.log("set_all_locations");
  // Go backwards
//  for (let i = family_tree.length-1; i>=0; i--) {
  for (let i = 0; i< family_tree.length; i++) {
    const generation = family_tree[i];
    // each generation we start on the left again
    let current_loc = 0;
    for (const i2 in generation) {
      const couple = generation[i2];
      couple.loc = current_loc;
      couple.gen = Number(i);

      console.log(couple.father + "," + couple.mother);
      if (couple.children) {
        const first = find_first_in_generation(couple.children[0], family_tree[i+1]);
        const last = find_last_in_generation(couple.children[couple.children.length-1], family_tree[i+1]);
        console.log(couple.father + "," + couple.mother + ": " + couple.loc + " [" + first + "," + last + "]");

//        if (couple.loc < first) {
//          couple.loc = first;
//          current_loc = first;
//        }


//        if (couple.loc < (first + last) / 2 ) {
//          couple.loc = (first + last) / 2 ;
//          current_loc = (first + last) / 2 ;
//        }
        const dads_parent = find_parent_of_male_in_couple(couple, family_tree);
        const moms_parent = find_parent_of_female_in_couple(couple, family_tree);
//        current_loc = current_loc + couple.children.length;

        current_loc = current_loc + 1;
        console.log(current_loc);
        if (dads_parent && dads_parent.loc > current_loc) current_loc = dads_parent.loc;
        if (moms_parent && moms_parent.loc > current_loc) current_loc = moms_parent.loc;

        if (dads_parent) {
          console.log(couple.father + "," + couple.mother + "->" + current_loc + " (" + dads_parent.loc + ")");
        }
        if (moms_parent) {
          console.log(couple.father + "," + couple.mother + "->" + current_loc + " (" + moms_parent.loc + ")");
        }
//        current_loc = first;
      } else {
        current_loc = current_loc + 1;
      }
    }
  }


  // Go back from top to bottom one more time to ensure that children start directly below their parents (or are to the right)
  for (const i in family_tree) {
    const generation = family_tree[i];
    // each generation we start on the left again
    // Once we find that we need to move someone, we need to move everyone after them
    let movement = 0;
    for (const i2 in generation) {
      const couple = generation[i2];
      if (movement > 0) couple.loc = couple.loc + movement;
      const dads_parent = find_parent_of_male_in_couple(couple, family_tree);
      const moms_parent = find_parent_of_female_in_couple(couple, family_tree);
      if (dads_parent && couple.loc < dads_parent.loc) {
        console.log(couple.father + "," + couple.mother + "->" + couple.loc + " (" + dads_parent.loc + ")");
        movement = dads_parent.loc - couple.loc;
        couple.loc = dads_parent.loc;
      }
      else if (moms_parent && couple.loc < moms_parent.loc) {
        console.log(couple.father + "," + couple.mother + "->" + couple.loc + " (" + moms_parent.loc + ")");
        movement = moms_parent.loc - couple.loc;
        couple.loc = moms_parent.loc;
      }

    }
  }

}


export function find_children(parent_id, exception_id) {
  let children = [];
  const people = data['people'];

  for (const person_id in people) {
    let details = people[person_id];

    if (details['father'] == parent_id || details['mother'] == parent_id) {
      if (person_id != exception_id) children.push(person_id);
    }
  }
  sort_people_by_age_name_id(children);

  return children;
}

export function is_childless(parent_id) {
  for (const person_id in data["people"]) {
    let details = data["people"][person_id];
    if (details['father'] == parent_id || details['mother'] == parent_id) {
      return false;
    }
  }
  return true;
}

export function find_all_partners(person_id) {
  if (!person_id) return null; // If no id, no partners

  let partners = [];

  let children = find_children(person_id);

  for (const index in children) {
    const child_id = children[index];
    const mother_id = data['people'][child_id]['mother'];
    const father_id = data['people'][child_id]['father'];
    if (mother_id && mother_id != person_id && !partners.includes(mother_id)) {
      partners.push(mother_id);
    }
    if (father_id && father_id != person_id && !partners.includes(father_id)) {
      partners.push(father_id);
    }
    if (!mother_id) {
      partners.push("UNKNOWN");
    }
    if (!father_id) {
      partners.push("UNKNOWN");
    }
  }
  return partners;
}


export function find_children_from_couple_excluding_child(couple, child_id) {
  if (!couple || !couple.father || !couple.mother) return null;

  let children = [];
  const people = data['people'];
  for (const person_id in people) {
    let details = people[person_id];
    if (details.father == couple.father && details.mother == couple.mother) {
      if (person_id != child_id) children.push(person_id);
    }

    if ( (details.father == couple.father)  && (couple.mother == "UNKNOWN" && !details.mother) ){
      if (person_id != child_id) children.push(person_id);
    }
    if ( (couple.father == "UNKNOWN" && !details.father) && (details.mother == couple.mother) ) {
      if (person_id != child_id) children.push(person_id);
    }
  }
  sort_people_by_age_name_id(children);
  if (couple.mother == "5711-04-002") console.log(children);

  return children;
}

export function find_children_from_couple(couple) {
  if (!couple || !couple.father || !couple.mother) return null;

  let children = [];
  const people = data['people'];
  for (const person_id in people) {
    let details = people[person_id];
    if (details.father == couple.father && details.mother == couple.mother) {
      children.push(person_id);
    }

    if ( (details.father == couple.father)  && (couple.mother == "UNKNOWN" && !details.mother) ){
      children.push(person_id);
    }
    if ( (couple.father == "UNKNOWN" && !details.father) && (details.mother == couple.mother) ) {
      children.push(person_id);
    }
  }
  sort_people_by_age_name_id(children);
  if (couple.mother == "5711-04-002") console.log(children);

  return children;
}

// Exception ID is if we wanted to find full siblings
export function find_children_from_both_parents(father_id, mother_id, exception_id) {
  let children = [];
  const people = data['people'];
  for (const [person_id, details] of Object.entries(people)) {
    if (details['father'] == father_id && details['mother'] == mother_id) {
      if (person_id != exception_id) children.push(person_id);
    }
  }
  sort_people_by_age_name_id(children);

  return children;
}


// Couple based functions

export function find_all_parents_of_list(list, generation) {
  let parents_list = [];

  let generation_has_people = false;
  for (let i in list) {
    const male_id = list[i].father;
    const female_id = list[i].mother;
    const loc = list[i].loc;

//    const person_id = list[index];
    // If both parents are mentioned, then put both on the list,

    if (female_id) {
      let couple = {};
      if (data['people'][female_id]) {
        couple.mother = data['people'][female_id]["mother"];
        couple.father = data['people'][female_id]["father"];
        couple.children = find_children_from_couple_excluding_child(couple, female_id);
        // Always put girl at end of the list
        if (couple.children) couple.children.push(female_id);
        couple.blood = true;
        couple.ancestor = true;
        if (couple.mother || couple.father) generation_has_people = true;
        if (!couple.mother) {
          couple.placeholder = false;
          couple.mother = "MOM_" + female_id;
          couple.children = [female_id];
          data['people'][female_id]["mother"] = "MOM_" + female_id;
//          console.log(data['people'][female_id]);
        }
        if (!couple.father) {
          couple.placeholder = false;
          couple.father = "DAD_" + female_id;
          couple.children = [female_id];
          data['people'][female_id]["father"] = "DAD_" + female_id;
//          console.log(data['people'][female_id]);
        }
//        console.log(couple, parents_list);
        if (couple.mother || couple.father) add_new_couple_to_list_unique(couple, parents_list);

      }
    }
    if (male_id) {
      let couple = {};
      if (data['people'][male_id]) {
        couple.mother = data['people'][male_id]["mother"];
        couple.father = data['people'][male_id]["father"];
        couple.children = find_children_from_couple_excluding_child(couple, male_id);
        // Always put boy at front of the list
        if (couple.children) couple.children.unshift(male_id);
        couple.blood = true;
        couple.ancestor = true;
        if (couple.mother || couple.father) generation_has_people = true;
        if (!couple.mother) {
          couple.placeholder = false;
          couple.mother = "MOM_" + male_id;
          couple.children = [male_id];
        data['people'][male_id]["mother"] = "MOM_" + male_id;
//          console.log(data['people'][male_id]);
      }
        if (!couple.father) {
          couple.placeholder = false;
          couple.father = "DAD_" + male_id;
          couple.children = [male_id];
          data['people'][male_id]["father"] = "DAD_" + male_id;
//          console.log(data['people'][male_id]);
        }
//        console.log(couple);
        if (couple.mother || couple.father) add_new_couple_to_list_unique(couple, parents_list);
      }
    }
  }
//  console.log(parents_list);
  if (generation_has_people) return parents_list;
  else return null;
}

export function find_parent_of_male_in_couple(couple, family_tree) {
  for (const i in family_tree) {
    const generation = family_tree[i];
    for (const i2 in generation) {
      const parent_couple = generation[i2];

  //    console.log(parent_couple.father + "," + parent_couple.mother + ":" + parent_couple.children);

      if (parent_couple.children && parent_couple.children.includes(couple.father)) return parent_couple;
    }
  }
}

export function find_parent_of_female_in_couple(couple, family_tree) {
  for (const i in family_tree) {
    const generation = family_tree[i];
    for (const i2 in generation) {
      const parent_couple = generation[i2];

  //    console.log(parent_couple.father + "," + parent_couple.mother + ":" + parent_couple.children);

      if (parent_couple.children && parent_couple.children.includes(couple.mother)) return parent_couple;

    }
  }
}

function add_new_couple_to_list_unique(couple, list) {
  let couple_already_in_list = false;
  for (let i=0; i<list.length;i++){
    const candidate_couple = list[i];
    if (candidate_couple.father == couple.father && candidate_couple.mother == couple.mother) {
      couple_already_in_list = true;
    }
  }
  if (!couple_already_in_list) {
    list.push(couple);
  }
}


///// Helper functions that do not need to be tested
function find_full_siblings(person_id) {
  const siblings = find_children_from_both_parents(person_id.father, person_id.mother);
  return siblings;
}

function find_any_siblings(person_id) {
  let siblings_from_father = [];
  let siblings_from_mother = [];
  if (data["people"][person_id].father) siblings_from_father = find_children(data["people"][person_id].father, person_id);
  if (data["people"][person_id].mother) siblings_from_mother = find_children(data["people"][person_id].mother, person_id);

  return siblings_from_father.concat(siblings_from_mother);
}

function sort_people_by_age_name_id (list) {
  list.sort(compare_by_age_name_id);
}

function compare_by_age_name_id(first_person_id, second_person_id) {
  if (first_person_id == second_person_id) return 0;


// First check sex, girls always first
  const first_gender = data['people'][first_person_id]["demographics"]["gender"];
  const second_gender = data['people'][second_person_id]["demographics"]["gender"];
  if (first_gender == "Female" && second_gender == "Male") return -1;
  else if (first_gender == "Male" && second_gender == "Female") return 1;

// First Check Age
    let age_1 = determine_age(data['people'][first_person_id]);
    let age_2 = determine_age(data['people'][second_person_id]);
    if (age_1 > age_2) return 1;
    if (age_1 < age_2) return -1;

// Then check Name alphabetically
    const name_1 = data['people'][first_person_id]['name'];
    const name_2 = data['people'][second_person_id]['name'];
    if (name_1 > name_2) return 1;
    if (name_1 < name_2) return -1;

    if (first_person_id > second_person_id) return 1;
    if (first_person_id < second_person_id) return -1;

    return 0;
}

export function determine_age(id) {
  if (!data['people'][id]) return 0;
  if (!data['people'][id]['demographics']) return 0;

  if (data['people'][id]['demographics']['age']) return data['people'][id]['demographics']['age'];

  if (data['people'][id]['demographics']['birthdate']) {
    const birthdate = new Date(data['people'][id]['demographics']['birthdate']);
    const age = calculate_age(birthdate);
    return age;
  }
}

// Short function from stackoverflow
function calculate_age(birthday) { // birthday is a date
  const ageDifMs = Date.now() - birthday;
  const ageDate = new Date(ageDifMs); // miliseconds from epoch
  return Math.abs(ageDate.getUTCFullYear() - 1970);
}



export function determine_sex (person_id) {
  if (!person_id) return "Unknown";
  const children = find_children(person_id);
  if (children.length > 0) {
    const first_child_id = children[0];
    const first_child_details = data["people"][first_child_id];

    if (first_child_details["father"] == person_id) return "Male";
    else if (first_child_details["mother"] == person_id) return "Female";
  } else {
    // Okay they have no children, so can't tell that way, next check for Demographics
    const sex = data["people"][person_id]["demographics"]["gender"];
    if (sex == "Male" || sex == "male" || sex == "M") return "Male";
    else if (sex == "Female" || sex == "female" || sex == "F") return "Female";
    else return "Unknown";
  }

  return "Unknown"; // Should never happen
}
